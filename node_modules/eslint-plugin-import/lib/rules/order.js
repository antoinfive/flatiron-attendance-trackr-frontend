'use strict';

var _lodash = require('lodash.find');

var _lodash2 = _interopRequireDefault(_lodash);

var _importType = require('../core/importType');

var _importType2 = _interopRequireDefault(_importType);

var _staticRequire = require('../core/staticRequire');

var _staticRequire2 = _interopRequireDefault(_staticRequire);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultGroups = ['builtin', 'external', 'parent', 'sibling', 'index'];

// REPORTING

function reverse(array) {
  return array.map(function (v) {
    return {
      name: v.name,
      rank: -v.rank,
      node: v.node
    };
  }).reverse();
}

function findOutOfOrder(imported) {
  if (imported.length === 0) {
    return [];
  }
  var maxSeenRankNode = imported[0];
  return imported.filter(function (importedModule) {
    var res = importedModule.rank < maxSeenRankNode.rank;
    if (maxSeenRankNode.rank < importedModule.rank) {
      maxSeenRankNode = importedModule;
    }
    return res;
  });
}

function report(context, imported, outOfOrder, order) {
  outOfOrder.forEach(function (imp) {
    var found = (0, _lodash2.default)(imported, function hasHigherRank(importedItem) {
      return importedItem.rank > imp.rank;
    });
    context.report(imp.node, '`' + imp.name + '` import should occur ' + order + ' import of `' + found.name + '`');
  });
}

function makeReport(context, imported) {
  var outOfOrder = findOutOfOrder(imported);
  if (!outOfOrder.length) {
    return;
  }
  // There are things to report. Try to minimize the number of reported errors.
  var reversedImported = reverse(imported);
  var reversedOrder = findOutOfOrder(reversedImported);
  if (reversedOrder.length < outOfOrder.length) {
    report(context, reversedImported, reversedOrder, 'after');
    return;
  }
  report(context, imported, outOfOrder, 'before');
}

// DETECTING

function computeRank(context, ranks, name, type) {
  return ranks[(0, _importType2.default)(name, context)] + (type === 'import' ? 0 : 100);
}

function registerNode(context, node, name, type, ranks, imported) {
  var rank = computeRank(context, ranks, name, type);
  if (rank !== -1) {
    imported.push({ name: name, rank: rank, node: node });
  }
}

function isInVariableDeclarator(node) {
  return node && (node.type === 'VariableDeclarator' || isInVariableDeclarator(node.parent));
}

var types = ['builtin', 'external', 'internal', 'parent', 'sibling', 'index'];

// Creates an object with type-rank pairs.
// Example: { index: 0, sibling: 1, parent: 1, external: 1, builtin: 2, internal: 2 }
// Will throw an error if it contains a type that does not exist, or has a duplicate
function convertGroupsToRanks(groups) {
  var rankObject = groups.reduce(function (res, group, index) {
    if (typeof group === 'string') {
      group = [group];
    }
    group.forEach(function (groupItem) {
      if (types.indexOf(groupItem) === -1) {
        throw new Error('Incorrect configuration of the rule: Unknown type `' + JSON.stringify(groupItem) + '`');
      }
      if (res[groupItem] !== undefined) {
        throw new Error('Incorrect configuration of the rule: `' + groupItem + '` is duplicated');
      }
      res[groupItem] = index;
    });
    return res;
  }, {});

  var omittedTypes = types.filter(function (type) {
    return rankObject[type] === undefined;
  });

  return omittedTypes.reduce(function (res, type) {
    res[type] = groups.length;
    return res;
  }, rankObject);
}

module.exports = function importOrderRule(context) {
  var options = context.options[0] || {};
  var ranks = void 0;

  try {
    ranks = convertGroupsToRanks(options.groups || defaultGroups);
  } catch (error) {
    // Malformed configuration
    return {
      Program: function Program(node) {
        context.report(node, error.message);
      }
    };
  }
  var imported = [];
  var level = 0;

  function incrementLevel() {
    level++;
  }
  function decrementLevel() {
    level--;
  }

  return {
    ImportDeclaration: function handleImports(node) {
      if (node.specifiers.length) {
        // Ignoring unassigned imports
        var name = node.source.value;
        registerNode(context, node, name, 'import', ranks, imported);
      }
    },
    CallExpression: function handleRequires(node) {
      if (level !== 0 || !(0, _staticRequire2.default)(node) || !isInVariableDeclarator(node.parent)) {
        return;
      }
      var name = node.arguments[0].value;
      registerNode(context, node, name, 'require', ranks, imported);
    },
    'Program:exit': function reportAndReset() {
      makeReport(context, imported);
      imported = [];
    },
    FunctionDeclaration: incrementLevel,
    FunctionExpression: incrementLevel,
    ArrowFunctionExpression: incrementLevel,
    BlockStatement: incrementLevel,
    'FunctionDeclaration:exit': decrementLevel,
    'FunctionExpression:exit': decrementLevel,
    'ArrowFunctionExpression:exit': decrementLevel,
    'BlockStatement:exit': decrementLevel
  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    groups: {
      type: 'array'
    }
  },
  additionalProperties: false
}];
//# sourceMappingURL=data:application/json;base64,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QTRCLElBQTVCLEVBQWtDLFFBQWxDLEVBQTRDLEtBQTVDLEVBQW1ELFFBQW5ELEVBRjBCO09BQTVCO0tBRGlCO0FBTW5CLG9CQUFnQixTQUFTLGNBQVQsQ0FBd0IsSUFBeEIsRUFBOEI7QUFDNUMsVUFBSSxVQUFVLENBQVYsSUFBZSxDQUFDLDZCQUFnQixJQUFoQixDQUFELElBQTBCLENBQUMsdUJBQXVCLEtBQUssTUFBTCxDQUF4QixFQUFzQztBQUNqRixlQURpRjtPQUFuRjtBQUdBLFVBQU0sT0FBTyxLQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLEtBQWxCLENBSitCO0FBSzVDLG1CQUFhLE9BQWIsRUFBc0IsSUFBdEIsRUFBNEIsSUFBNUIsRUFBa0MsU0FBbEMsRUFBNkMsS0FBN0MsRUFBb0QsUUFBcEQsRUFMNEM7S0FBOUI7QUFPaEIsb0JBQWdCLFNBQVMsY0FBVCxHQUEwQjtBQUN4QyxpQkFBVyxPQUFYLEVBQW9CLFFBQXBCLEVBRHdDO0FBRXhDLGlCQUFXLEVBQVgsQ0FGd0M7S0FBMUI7QUFJaEIseUJBQXFCLGNBQXJCO0FBQ0Esd0JBQW9CLGNBQXBCO0FBQ0EsNkJBQXlCLGNBQXpCO0FBQ0Esb0JBQWdCLGNBQWhCO0FBQ0EsZ0NBQTRCLGNBQTVCO0FBQ0EsK0JBQTJCLGNBQTNCO0FBQ0Esb0NBQWdDLGNBQWhDO0FBQ0EsMkJBQXVCLGNBQXZCO0dBekJGLENBeEJrRDtDQUFuQzs7QUFxRGpCLE9BQU8sT0FBUCxDQUFlLE1BQWYsR0FBd0IsQ0FDdEI7QUFDRSxRQUFNLFFBQU47QUFDQSxjQUFZO0FBQ1YsWUFBUTtBQUNOLFlBQU0sT0FBTjtLQURGO0dBREY7QUFLQSx3QkFBc0IsS0FBdEI7Q0FSb0IsQ0FBeEIiLCJmaWxlIjoicnVsZXMvb3JkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuaW1wb3J0IGZpbmQgZnJvbSAnbG9kYXNoLmZpbmQnXG5pbXBvcnQgaW1wb3J0VHlwZSBmcm9tICcuLi9jb3JlL2ltcG9ydFR5cGUnXG5pbXBvcnQgaXNTdGF0aWNSZXF1aXJlIGZyb20gJy4uL2NvcmUvc3RhdGljUmVxdWlyZSdcblxuY29uc3QgZGVmYXVsdEdyb3VwcyA9IFsnYnVpbHRpbicsICdleHRlcm5hbCcsICdwYXJlbnQnLCAnc2libGluZycsICdpbmRleCddXG5cbi8vIFJFUE9SVElOR1xuXG5mdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdi5uYW1lLFxuICAgICAgcmFuazogLXYucmFuayxcbiAgICAgIG5vZGU6IHYubm9kZSxcbiAgICB9XG4gIH0pLnJldmVyc2UoKVxufVxuXG5mdW5jdGlvbiBmaW5kT3V0T2ZPcmRlcihpbXBvcnRlZCkge1xuICBpZiAoaW1wb3J0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgbGV0IG1heFNlZW5SYW5rTm9kZSA9IGltcG9ydGVkWzBdXG4gIHJldHVybiBpbXBvcnRlZC5maWx0ZXIoZnVuY3Rpb24gKGltcG9ydGVkTW9kdWxlKSB7XG4gICAgY29uc3QgcmVzID0gaW1wb3J0ZWRNb2R1bGUucmFuayA8IG1heFNlZW5SYW5rTm9kZS5yYW5rXG4gICAgaWYgKG1heFNlZW5SYW5rTm9kZS5yYW5rIDwgaW1wb3J0ZWRNb2R1bGUucmFuaykge1xuICAgICAgbWF4U2VlblJhbmtOb2RlID0gaW1wb3J0ZWRNb2R1bGVcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9KVxufVxuXG5mdW5jdGlvbiByZXBvcnQoY29udGV4dCwgaW1wb3J0ZWQsIG91dE9mT3JkZXIsIG9yZGVyKSB7XG4gIG91dE9mT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoaW1wKSB7XG4gICAgY29uc3QgZm91bmQgPSBmaW5kKGltcG9ydGVkLCBmdW5jdGlvbiBoYXNIaWdoZXJSYW5rKGltcG9ydGVkSXRlbSkge1xuICAgICAgcmV0dXJuIGltcG9ydGVkSXRlbS5yYW5rID4gaW1wLnJhbmtcbiAgICB9KVxuICAgIGNvbnRleHQucmVwb3J0KGltcC5ub2RlLCAnYCcgKyBpbXAubmFtZSArICdgIGltcG9ydCBzaG91bGQgb2NjdXIgJyArIG9yZGVyICtcbiAgICAgICcgaW1wb3J0IG9mIGAnICsgZm91bmQubmFtZSArICdgJylcbiAgfSlcbn1cblxuZnVuY3Rpb24gbWFrZVJlcG9ydChjb250ZXh0LCBpbXBvcnRlZCkge1xuICBjb25zdCBvdXRPZk9yZGVyID0gZmluZE91dE9mT3JkZXIoaW1wb3J0ZWQpXG4gIGlmICghb3V0T2ZPcmRlci5sZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvLyBUaGVyZSBhcmUgdGhpbmdzIHRvIHJlcG9ydC4gVHJ5IHRvIG1pbmltaXplIHRoZSBudW1iZXIgb2YgcmVwb3J0ZWQgZXJyb3JzLlxuICBjb25zdCByZXZlcnNlZEltcG9ydGVkID0gcmV2ZXJzZShpbXBvcnRlZClcbiAgY29uc3QgcmV2ZXJzZWRPcmRlciA9IGZpbmRPdXRPZk9yZGVyKHJldmVyc2VkSW1wb3J0ZWQpXG4gIGlmIChyZXZlcnNlZE9yZGVyLmxlbmd0aCA8IG91dE9mT3JkZXIubGVuZ3RoKSB7XG4gICAgcmVwb3J0KGNvbnRleHQsIHJldmVyc2VkSW1wb3J0ZWQsIHJldmVyc2VkT3JkZXIsICdhZnRlcicpXG4gICAgcmV0dXJuXG4gIH1cbiAgcmVwb3J0KGNvbnRleHQsIGltcG9ydGVkLCBvdXRPZk9yZGVyLCAnYmVmb3JlJylcbn1cblxuLy8gREVURUNUSU5HXG5cbmZ1bmN0aW9uIGNvbXB1dGVSYW5rKGNvbnRleHQsIHJhbmtzLCBuYW1lLCB0eXBlKSB7XG4gIHJldHVybiByYW5rc1tpbXBvcnRUeXBlKG5hbWUsIGNvbnRleHQpXSArXG4gICAgKHR5cGUgPT09ICdpbXBvcnQnID8gMCA6IDEwMClcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJOb2RlKGNvbnRleHQsIG5vZGUsIG5hbWUsIHR5cGUsIHJhbmtzLCBpbXBvcnRlZCkge1xuICBjb25zdCByYW5rID0gY29tcHV0ZVJhbmsoY29udGV4dCwgcmFua3MsIG5hbWUsIHR5cGUpXG4gIGlmIChyYW5rICE9PSAtMSkge1xuICAgIGltcG9ydGVkLnB1c2goe25hbWUsIHJhbmssIG5vZGV9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5WYXJpYWJsZURlY2xhcmF0b3Iobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJlxuICAgIChub2RlLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InIHx8IGlzSW5WYXJpYWJsZURlY2xhcmF0b3Iobm9kZS5wYXJlbnQpKVxufVxuXG5jb25zdCB0eXBlcyA9IFsnYnVpbHRpbicsICdleHRlcm5hbCcsICdpbnRlcm5hbCcsICdwYXJlbnQnLCAnc2libGluZycsICdpbmRleCddXG5cbi8vIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdHlwZS1yYW5rIHBhaXJzLlxuLy8gRXhhbXBsZTogeyBpbmRleDogMCwgc2libGluZzogMSwgcGFyZW50OiAxLCBleHRlcm5hbDogMSwgYnVpbHRpbjogMiwgaW50ZXJuYWw6IDIgfVxuLy8gV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBpdCBjb250YWlucyBhIHR5cGUgdGhhdCBkb2VzIG5vdCBleGlzdCwgb3IgaGFzIGEgZHVwbGljYXRlXG5mdW5jdGlvbiBjb252ZXJ0R3JvdXBzVG9SYW5rcyhncm91cHMpIHtcbiAgY29uc3QgcmFua09iamVjdCA9IGdyb3Vwcy5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBncm91cCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGdyb3VwID09PSAnc3RyaW5nJykge1xuICAgICAgZ3JvdXAgPSBbZ3JvdXBdXG4gICAgfVxuICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24oZ3JvdXBJdGVtKSB7XG4gICAgICBpZiAodHlwZXMuaW5kZXhPZihncm91cEl0ZW0pID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBjb25maWd1cmF0aW9uIG9mIHRoZSBydWxlOiBVbmtub3duIHR5cGUgYCcgK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGdyb3VwSXRlbSkgKyAnYCcpXG4gICAgICB9XG4gICAgICBpZiAocmVzW2dyb3VwSXRlbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBjb25maWd1cmF0aW9uIG9mIHRoZSBydWxlOiBgJyArIGdyb3VwSXRlbSArICdgIGlzIGR1cGxpY2F0ZWQnKVxuICAgICAgfVxuICAgICAgcmVzW2dyb3VwSXRlbV0gPSBpbmRleFxuICAgIH0pXG4gICAgcmV0dXJuIHJlc1xuICB9LCB7fSlcblxuICBjb25zdCBvbWl0dGVkVHlwZXMgPSB0eXBlcy5maWx0ZXIoZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiByYW5rT2JqZWN0W3R5cGVdID09PSB1bmRlZmluZWRcbiAgfSlcblxuICByZXR1cm4gb21pdHRlZFR5cGVzLnJlZHVjZShmdW5jdGlvbihyZXMsIHR5cGUpIHtcbiAgICByZXNbdHlwZV0gPSBncm91cHMubGVuZ3RoXG4gICAgcmV0dXJuIHJlc1xuICB9LCByYW5rT2JqZWN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltcG9ydE9yZGVyUnVsZSAoY29udGV4dCkge1xuICBjb25zdCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zWzBdIHx8IHt9XG4gIGxldCByYW5rc1xuXG4gIHRyeSB7XG4gICAgcmFua3MgPSBjb252ZXJ0R3JvdXBzVG9SYW5rcyhvcHRpb25zLmdyb3VwcyB8fCBkZWZhdWx0R3JvdXBzKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIE1hbGZvcm1lZCBjb25maWd1cmF0aW9uXG4gICAgcmV0dXJuIHtcbiAgICAgIFByb2dyYW06IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnQobm9kZSwgZXJyb3IubWVzc2FnZSlcbiAgICAgIH0sXG4gICAgfVxuICB9XG4gIGxldCBpbXBvcnRlZCA9IFtdXG4gIGxldCBsZXZlbCA9IDBcblxuICBmdW5jdGlvbiBpbmNyZW1lbnRMZXZlbCgpIHtcbiAgICBsZXZlbCsrXG4gIH1cbiAgZnVuY3Rpb24gZGVjcmVtZW50TGV2ZWwoKSB7XG4gICAgbGV2ZWwtLVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBJbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24gaGFuZGxlSW1wb3J0cyhub2RlKSB7XG4gICAgICBpZiAobm9kZS5zcGVjaWZpZXJzLmxlbmd0aCkgeyAvLyBJZ25vcmluZyB1bmFzc2lnbmVkIGltcG9ydHNcbiAgICAgICAgY29uc3QgbmFtZSA9IG5vZGUuc291cmNlLnZhbHVlXG4gICAgICAgIHJlZ2lzdGVyTm9kZShjb250ZXh0LCBub2RlLCBuYW1lLCAnaW1wb3J0JywgcmFua3MsIGltcG9ydGVkKVxuICAgICAgfVxuICAgIH0sXG4gICAgQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIGhhbmRsZVJlcXVpcmVzKG5vZGUpIHtcbiAgICAgIGlmIChsZXZlbCAhPT0gMCB8fCAhaXNTdGF0aWNSZXF1aXJlKG5vZGUpIHx8ICFpc0luVmFyaWFibGVEZWNsYXJhdG9yKG5vZGUucGFyZW50KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLmFyZ3VtZW50c1swXS52YWx1ZVxuICAgICAgcmVnaXN0ZXJOb2RlKGNvbnRleHQsIG5vZGUsIG5hbWUsICdyZXF1aXJlJywgcmFua3MsIGltcG9ydGVkKVxuICAgIH0sXG4gICAgJ1Byb2dyYW06ZXhpdCc6IGZ1bmN0aW9uIHJlcG9ydEFuZFJlc2V0KCkge1xuICAgICAgbWFrZVJlcG9ydChjb250ZXh0LCBpbXBvcnRlZClcbiAgICAgIGltcG9ydGVkID0gW11cbiAgICB9LFxuICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IGluY3JlbWVudExldmVsLFxuICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogaW5jcmVtZW50TGV2ZWwsXG4gICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGluY3JlbWVudExldmVsLFxuICAgIEJsb2NrU3RhdGVtZW50OiBpbmNyZW1lbnRMZXZlbCxcbiAgICAnRnVuY3Rpb25EZWNsYXJhdGlvbjpleGl0JzogZGVjcmVtZW50TGV2ZWwsXG4gICAgJ0Z1bmN0aW9uRXhwcmVzc2lvbjpleGl0JzogZGVjcmVtZW50TGV2ZWwsXG4gICAgJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uOmV4aXQnOiBkZWNyZW1lbnRMZXZlbCxcbiAgICAnQmxvY2tTdGF0ZW1lbnQ6ZXhpdCc6IGRlY3JlbWVudExldmVsLFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLnNjaGVtYSA9IFtcbiAge1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGdyb3Vwczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgfSxcbl1cbiJdfQ==