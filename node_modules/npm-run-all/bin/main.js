"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

exports.default = npmRunAll;

var _npmRunAll = require("../lib/npm-run-all");

var _npmRunAll2 = _interopRequireDefault(_npmRunAll);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var START_PROMISE = _promise2.default.resolve(null); /**
                                                      * @author Toru Nagashima
                                                      * @copyright 2015 Toru Nagashima. All rights reserved.
                                                      * See LICENSE file in root directory for full license.
                                                      */
/* eslint no-process-env: 0 */

var OVERWRITE_OPTION = /^--([^:]+?):([^=]+?)(?:=(.+))?$/;
var CONFIG_PATTERN = /^npm_package_config_(.+)$/;

/**
 * Overwrites a specified package config.
 *
 * @param {object} config - A config object to be overwritten.
 * @param {string} packageName - A package name to overwrite.
 * @param {string} variable - A variable name to overwrite.
 * @param {string} value - A new value to overwrite.
 * @returns {void}
 */
function overwriteConfig(config, packageName, variable, value) {
    var scope = config[packageName] || (config[packageName] = {}); // eslint-disable-line no-param-reassign
    scope[variable] = value;
}

/**
 * Creates a package config object.
 * This checks `process.env` and creates the default value.
 *
 * @returns {object} Created config object.
 */
function createPackageConfig() {
    var retv = {};
    var packageName = process.env.npm_package_name;
    if (!packageName) {
        return retv;
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(process.env)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            var m = CONFIG_PATTERN.exec(key);
            if (m != null) {
                overwriteConfig(retv, packageName, m[1], process.env[key]);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return retv;
}

/**
 * Parses arguments.
 *
 * @param {string[]} args - Arguments to parse.
 * @returns {{
 *      groups: {
 *          parallel: boolean,
 *          continueOnError: boolean,
 *          patterns: string[]
 *      }[],
 *      packageConfig: object
 * }} A running plan.
 */
function parse(args) {
    var packageConfig = createPackageConfig();
    var groups = [{
        parallel: false,
        continueOnError: false,
        printLabel: false,
        printName: false,
        patterns: []
    }];

    for (var i = 0; i < args.length; ++i) {
        var arg = args[i];

        switch (arg) {
            case "-S":
            case "-s":
            case "--sequential":
            case "--serial":
                groups.push({
                    parallel: false,
                    continueOnError: arg === "-S",
                    printLabel: false,
                    printName: false,
                    patterns: []
                });
                break;

            case "-P":
            case "-p":
            case "--parallel":
                groups.push({
                    parallel: true,
                    continueOnError: arg === "-P",
                    printLabel: false,
                    printName: false,
                    patterns: []
                });
                break;

            case "-c":
            case "--continue-on-error":
                groups[groups.length - 1].continueOnError = true;
                break;

            case "-l":
            case "--print-label":
                groups[groups.length - 1].printLabel = true;
                break;

            case "-n":
            case "--print-name":
                groups[groups.length - 1].printName = true;
                break;

            case "--color":
            case "--no-color":
            case "--silent":
                // do nothing.
                break;

            default:
                {
                    var matched = OVERWRITE_OPTION.exec(arg);
                    if (matched) {
                        overwriteConfig(packageConfig, matched[1], matched[2], matched[3] || args[++i]);
                    } else if (arg[0] === "-") {
                        throw new Error("Invalid Option: " + arg);
                    } else {
                        groups[groups.length - 1].patterns.push(arg);
                    }
                    break;
                }
        }
    }

    return { groups: groups, packageConfig: packageConfig };
}

/**
 * Parses arguments, then run specified npm-scripts.
 *
 * @param {string[]} args - Arguments to parse.
 * @param {stream.Writable} stdout - A writable stream to print logs.
 * @param {stream.Writable} stderr - A writable stream to print errors.
 * @returns {Promise} A promise which comes to be fulfilled when all npm-scripts are completed.
 * @private
 */
function npmRunAll(args, stdout, stderr) {
    try {
        var _ret = function () {
            var stdin = process.stdin;
            var silent = args.indexOf("--silent") !== -1 || process.env.npm_config_loglevel === "silent";

            var _parse = parse(args);

            var groups = _parse.groups;
            var packageConfig = _parse.packageConfig;


            return {
                v: groups.reduce(function (prev, _ref) {
                    var patterns = _ref.patterns;
                    var parallel = _ref.parallel;
                    var continueOnError = _ref.continueOnError;
                    var printLabel = _ref.printLabel;
                    var printName = _ref.printName;

                    if (patterns.length === 0) {
                        return prev;
                    }
                    return prev.then(function () {
                        return (0, _npmRunAll2.default)(patterns, {
                            stdout: stdout,
                            stderr: stderr,
                            stdin: stdin,
                            parallel: parallel,
                            continueOnError: continueOnError,
                            printLabel: printLabel,
                            printName: printName,
                            packageConfig: packageConfig,
                            silent: silent
                        });
                    });
                }, START_PROMISE)
            };
        }();

        if ((typeof _ret === "undefined" ? "undefined" : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
    } catch (err) {
        return _promise2.default.reject(err);
    }
}